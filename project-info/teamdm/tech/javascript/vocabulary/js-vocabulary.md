# identifier

- a particular name generated by the programmer to define a variable, a class, structure, or a function.
- these words are provided by the programmer.
- ex: `let`, `function`

# reserved identifier

- reserved keywords used as identifiers. Ex: `let`, `package`, `enum`

# reserved word (AKA reserved keyword)

- a predefined and specific words in the language that hold a special meaning
- a word that cannot be used as an identifier, such as the name of a variable, function, or labels.
- ex: `let`, `sort`, `this`, `charAt`, `function`

## Logical AND(&&) and OR(||) operators

- logical AND operator - uses the double `ampersand(&&)` to represent the logical AND operator.
  The result of the `&&` operator is true only if both values are true, otherwise, it is false.
- logical OR operator - uses the double `pipe(||)` to represent the logical OR operator.
  The result of the `||` operator is true if either of the values is true.
  // DM: todoDM: add notes about "short-circuiting evaluation" to the definitions of &&, ||
- DM: "expr1 || expr2" evaluates to expr1

// DM: todoDM: what are both operators called as a group? also, what is the exact word for 'result' of the evaluation of a "logical expression"?

## difference between string interpolation and template literal

A template literal is a placeholder used in JavaScript for string interpolation and expressions with a dollar sign and curly braces, while string interpolation is used to concatenate string with the plus sign.

## template literal

Template literals are literals delimited with backtick ( ` ) characters, allowing for multi-line strings, string interpolation with embedded expressions, and special constructs called tagged templates

## short-circuiting evaluation

the semantics of some Boolean operators in some programming languages in which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression
DM: todoDM: concise examples from my Anki

## destructuring assignment(object and array destructuring)

The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.
Example can be found in the `src/utils/array/snippets/destructuring.js`

## default values

this method allows to get a default value of a destructuring parameter property that has not been given.
ex: const { property1 = 'defaultValue} = {}

DM: good stuff!

## module

a file containing related code. we use the `import` and `export` keywords to share and receive functionalities respectively across different modules. The `export` keyword is used to make a variable, function, class or object accessible to other modules.

- DM: great! keep making new entries for any term you see that is not familiar
-

## default export vs named export

- named export - export one or more values (functions, variables) per module, and import with _curly brackets_.
- default export allows only one export per module and without any curly brackets.

## brackets

{} curly brackets
() parentheses
[] square brackets
<> angle brackets

## class prototype

Prototypes are the mechanism by which JavaScript objects inherit features from one another

<!-- an example from the ./class-prototype/class.js -->

## the number type - truthy/falsy

Every number in JavaScript is `truthy`(a truthy value is a value that is considered true when encountered in a Boolean context), except zero(`0`) which is "falsy" just like how an empty string (`''`) is the only "falsy" string.

- other falsy values are : `false`, `null`, `undefined`, `NaN`, `0n`

## boolean constructor

The Boolean() _built-in constructor_ can create boolean objects or return primitive values of type boolean.

```js
new Boolean(value) // called as a constructor (with new), it creates a Boolean object, which is NOT a primitive.
// DM: I did not know this!
Boolean(value) // *called as a function* (without new), it coerces the parameter to a boolean PRIMITIVE.
```

## built-in constructors for native objects

ex: Object(), String(), Boolean(), RegExp(), Number(), Array(), Function(), Date()
Note We cannot include Math object in those built-in constructors because Math is a global object. (todoDM: more)

## custom constructors

DM: todoDM

## array literal

An array literal is a _list_ of zero or more _expressions_, each of which represents an array _element_, enclosed in _square brackets_ ( [] )

## object literal

An object literal is a _compound data type_ of zero or more pairs of *property name*s and associated values of an object, enclosed in _curly brackets_ ( {} )
`const myObj = {propertyName: 'value'}`

DM: great work!

(done) DM: todoMM: add to programming vocab: compound data type; I added it in the programming-vocabulary.md file.

## data type

There are four 'primitive' or basic data types, from which all others can be created

These are known as:

- integer (whole numbers)
- real (numbers with a fraction part)
- Boolean (True/False)
- char (characters)

But in JavaScript there are eight:

- String
- Number
- Boolean
- Undefined
- Null as primitive
- Bigint
- Symbol
- Object as non-primitive

# curly|square|angle|round brackets

- DM: I like to pick one word, "brackets", to keep it simple. This is also more internationalized (i18n) You can say curly braces and parentheses (instead of round brackets).

## css-in-js

CSS-in-JS is different from inline styles. We still write all our CSS in JavaScript, but instead of passing it to the style attribute, we take those styles and inject an actual string of CSS in a <style> tag into the DOM

## recursive function

A recursive function is a function that **calls itself** _until it doesn’t_.

verb form: "to recurse"; ex: "the algorithm recurses on the children of the current item"

## property access: dot notation vs. bracket notation

- operators: member access vs. computed member access
  - member access operator (using dot notation)
  - computed member access operator (using bracket notation)
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#dot_notation
- The difference is in how a property value is interpreted.
  - When using a dot, the part after the dot must be a valid property name of the object, and it directly names the property.
  - When using square brackets, the _expression_ between the brackets is _evaluated_ to get the property name. Ex: myObject[x] tries to evaluate the expression x and uses the result as the property name.

```js
const myObject = {
  myPropertyName: 'my property value',
  'my property name with spaces': 'my property value with spaces',
}
myObject.myPropertyName
myObject['my property name with spaces'] // 'my property name with spaces' is an expression
myObject.my property name with spaces // SyntaxError: Unexpected token
myObject.'my property name with spaces' // SyntaxError: Unexpected token
const myPropertyNameInAVariable = 'myPropertyName'
myObject[myPropertyNameInAVariable] // myPropertyNameInAVariable is an expression
myObject.myPropertyNameInAVariable // error! myPropertyNameInAVariable is undefined (not a property of myObject)
```

## hoisting

JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior to execution of the code.

## Assignment (=)

The assignment ( = ) operator is used to assign a value to a variable. The assignment operation evaluates to the assigned value. Chaining the assignment operator is possible in order to assign a single value to multiple variables

## mutation

- A value is said to be mutable if it can be changed, altered
- a mutation is the act of changing the properties of an object, or the value of a declared variable.
- but, all primitive values in JavaScript are immutable:
  - you can't change their properties — ever
  - they cannot be altered
  - but their value can be reassigned
- let - you can reassign and mutate (objects)
- const - cannot reassign, but can mutate
- often an interview question. memorize a short answer. be careful to not get 'lost in the weeds'

# object

- { property: value }
- anything that is not a primitive: array, regExp, date
  - note: all can be instantiated via the 'new' operator: const date = new Date()
    - but, so can a string: const myString = new String('hello') // DM: todoDM: is myString an object or primitive
    - also, number: const myNumber = new Number(1);
    -

## type coercion

- automatic or implicit conversion of values from one data type to another
- happens implicitly when operators or functions are applied to values of different types
- examples:

  - 4 + '5' // '45' // 4 was coerced to '4' then concatenated with '5'
  - 4 + Number(5) // 9 // '5' was converted to 5 then added to 4
  - [].filter(mySubstring => [].find(myString => myString.includes(mySubstring)))
    - Array.filter() expects a Boolean
    - but Array.find() returns the matching myString || undefined
    - therefore, Array.filter() code coerces myString || undefined to Boolean

  return firstArray
  .filter((substring) => {
  return secondArray.find((string) => string.includes(substring))
  /_
  'arp' || undefined || '' || '0' || 0
  Boolean('arp') === true // string to true
  Boolean(undefined) === false // undefined to false
  type coercion
  _/
  })
  .sort()
  Boolean('arp') // converts 'arp' to Boolean "explicitly"; "explicit conversion"
  'arp' === true // false
  'arp' == true // true - "==" "implicitly" coerces 'arp' to Boolean; "implicit conversion"

## abstract equality comparison operator(==) vs strict equality comparison operator(===)

- The abstract equality operator performs a _**loose** equality_ comparison that performs type coercion if necessary to make the comparison possible.
- The strict equality operator, on the other hand, performs a _strict equality_ comparison that does not perform type coercion and requires the operands to have the same type (as well as the same value).

https://www.pluralsight.com/blog/software-development/vs-javascript-abstract-vs-strict-equality

## truthy/falsy VS Boolean()

- the 7 falsy values: false, 0, 0n, '', null, undefined, NaN (mnemonic: F00'nun)
- truthy = NOT falsy
- truthy/falsy is implemented by
  - `if ()`
  - `Boolean()`
  - (but not `==`, which follow the JS rules of type coercion, which are weird).
  - exit conditions on constructs like `for` and `while`.
  - By extension, _predicate functions_, like those passed to Array.filter and Array.find, also operate based on truthiness.
  - operators:
    - `!` negation operator
    - `&&` and `||` logical operators
      - called short-circuiting operators because they evaluate their operands from left to right and stop at the first value that guarantees the value of the expression.
      - Short-circuiting expressions produce whatever value determined the truthiness of the expression, not necessarily a boolean:
        - `0 || 42 // 42`
        - `const obj = { ...( truthy && { foo: 'bar' } ) }`
          - note: `{ ...anyFalsyValue } // {}`
          - also: `{ ...[] } // {}`
    - ?...: conditional (ternary) operator
  - Truthiness is inherent in every JavaScript value and is used implicitly by the runtime anytime a boolean evaluation of the value is required.

// == (JS "abstract equality" is weird, so DON'T USE ==, DO USE ===)
false == 0 // true
0 == 0n // true
0n == '' // true
'' == null // false // empty string can't be coerced to null or vice versa
null == undefined // true
undefined == NaN // false // undefined can't be coerced to NaN or vice versa

// if ()
if (false || 0 || 0n || '' || null || undefined || NaN) console.log('never logged')

// Boolean()
Boolean(false) === Boolean(0) // true
Boolean(0) === Boolean(0n) // true
Boolean(0n) === Boolean('') // true
Boolean('') === Boolean(null) // true
Boolean(null) === Boolean(undefined) // true
Boolean(undefined) === Boolean(NaN) // true

// ?? nullish coalescing operator handles both `null` and `undefined` and solves some of the drawbacks of truthiness/falsiness
const foo = null ?? 'default string'; // 'default string'
const baz = 0 ?? 42; // 0 // however, 0 is a valid number value that happens to be falsy
const bar = 0 || 42; // 42
const boo = '' || 'some string value' // 'some string value' // however, '' may be a valid value
const fax = '' ?? 'some string value' // ''

## escape sequences

Escape sequences are typically used to specify actions such as carriage returns and tab movements on terminals and printers. They are also used to provide literal representations of non printing characters and characters that usually have special meanings, such as the double quotation mark (")

## array methods

Array methods are functions built-in to JavaScript that we can apply to the arrays — Each method has a unique function that performs a change or calculation to the array and saves us from writing common functions from scratch.

- e.g: `array.map(), array.startsWith()`
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

## object property

Properties are the values associated with a JavaScript object. A JavaScript object is a collection of unordered properties. Properties can usually be changed, added, and deleted, but some are read only.

- e.g: `array.length`

## method

a function that is a property of an object

- ex: built-in methods: String methods, Number methods
- ex: custom: we can create an object with properties that are functions:
  ```js
  const myObj = {
    myMethod: () => {},
    // howtojs: object: method: call another method that is defined in the same object; only works with regular functions (not arrow functions)
    anotherMethod: function () {}, // arrow methods cannot be called directly in the same object
    methodThatCallsAMethod: () => this.anotherMethod(),
  }
  myOby.myMethod()
  ```

## reassignment

Reassignment is the process of changing variable assignment or when their value changes to that of the newer value specified, and the previous value is lost by using the `let` key word

- for example:
  ```js
  let person = 'Joe'
  person = 'Doe'
  ```

## nodejs

Node.js is a back-end JavaScript runtime environment, runs on the V8 JavaScript Engine, and executes JavaScript code outside a web browser.

## NodeJS vs JavaScript

- NodeJS is a javascript runtime environment that runs on the server
- JavaScript runs in the browser.

## when edit an API endpoint, are you writing NodeJS or JavaScript?

Both. An API endpoint is written in NodeJS (which is server-side JavaScript)

## argument object

In JavaScript, inside a function, the arguments object has the values of arguments passed to that function. Using the arguments object, we can point to all of the functions passed to a function. The arguments object has properties similar to an array, so we can pick individual values by using the array indexing notation

- e.g:

```js
function argumentsObject(a, b, c) {
  console.log(arguments[0]) // 1
  console.log(arguments[1]) // 2
}

argumentsObject('a', 'b')
```

- Note: The object arguments is not an Array. It is similar to an Array, but does not have any Array properties except `length`. However, it can be converted to a real array using the `Array.prototype.slice`. Technically, it is called an "array-like object".

// DM: nice, good job on these new entries (delete this line after you read it, Moise)

```js
function argumentsObject() {
  return Array.prototype.slice.call(arguments)
}
argumentsObject()
```

note: not available in array functions

## web API

A web API is an application programming interface for either a web server or a web browser. As a web development concept, it can be related to a web application's client side.

## ECMAScript

- Is a standard for scripting languages including JavaScript (and technically also JScript, and ActionScript). It is also best known as a JavaScript standard intended to ensure the interoperability of web pages across different web browsers.
- basically it is THE JS specification
- the origin of the ES in the "ES6" version of JS

### ECMAScript vs JavaScript

- JavaScript is the programming language that is implemented by various platforms (browsers, Node.js, Deno, etc.)
- ECMAScript is its standard, as described in the ECMAScript language specification.
- FAQ: https://2ality.com/2022/06/ecmascript-2022.html#faq (cool!)

## CommonJS

CommonJS is a project to standardize the module ecosystem for JavaScript outside of web browsers. CommonJS's specification of how modules should work is widely used today for server-side JavaScript with Node.js. Increasingly ES Modules is used in NodeJS, and always in nextjs API routes.

## why are functions called first class objects in js?

In JavaScript, functions are first-class objects, because they can be passed to other functions, returned from functions, and assigned to variables and properties.

## scope

Scope in JavaScript refers to the current context of code, which determines the accessibility of variables to JavaScript. The two types of scope are ***local and global***: 
  **Global variables** are those declared outside of a block. 
  ***Local variables*** are those declared inside of a block.

## global scope
The global scope is JavaScript’s outermost scope. It has two kinds of variables: `object variables` (managed via the global object) and normal `declarative variables`. Each ECMAScript module has its own scope which is contained in the global scope.

## global object 
The global object in JavaScript is an always defined object that provides variables and functions, and is available anywhere. In a web browser, the global object is the window object, while it is named global in Node.js. The global object can be accessed using the this operator in the global scope. ***They are created in the top level of a script, via var and function declarations***

## global variable

Global Variables are the variables that can be accessed from anywhere in the program. These are the variables that are declared in the main body of the source code and outside all the functions. ***They can only be created while at the top level of a script, via const, ‘let, and class declarations***

## temporal dead zone
A temporal dead zone (TDZ) is the lines where a variable is inaccessible until the moment the computer initializes it with a value. Initialization occurs when one assigns an initial value to a variable.

## A closure
A closure is a feature of JavaScript that allows inner functions to access the outer scope of a function. Closure helps in binding a function to its outer boundary and is created automatically whenever a function is created. A block is also treated as a scope since ES6. ***Static scoping is supported via closures in JavaScript. Therefore, every function is
a closure***

(done)DM: todoMM: great. Add vocab "static scoping" to this file.

## lexical scoping AKA static scoping


Variables in JavaScript are lexically scoped
so the static structure of a program determines the scope of a variable. Variable scope is not influenced by, say, where a function is called.

```js
const myVar = 1
export default function myFunction() { // closure
  return myVar
}
// it doesn't matter where this is called
// the "scope" is always the same and the value always is 1.
```
